<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../google-map/google-map.html">
<link rel="import" href="../google-map/google-map-marker.html">
<link rel="import" href="../google-map/google-map-search.html">
<link rel="import" href="../google-map/google-map-directions.html">
<script src="./lib/utils.js"></script>
<script src="./bower_components/async/lib/async.js"></script>
<!--
An element providing a solution to no problem in particular.

Example:

    <gm-viz></gm-viz>

@demo
-->
<dom-module id="geo-visualizer">

  <style>
    :host {
      display: block;
      height: 100%;
    }

    :host google-map {
      float:left;
      width: 100%;
      height: 100%;
  }

  </style>

  <template>
    <google-map fitToMarkers="true"></google-map>
    <div class="content">
      <content></content>
    </div>
  </template>

</dom-module>

<script>
   function combinations(arr, k){
          var i, subI, ret = [], sub, next;
          return arr.reduce(
            function (acc, v, i){
              if (k === 1){ 
                acc = acc.concat([[v]]);
              } else {
                combinations(arr.slice(i+1, arr.length), k-1).forEach(
                  function (sv, si){
                    acc = acc.concat([[v].concat(sv)]);
                  }
                );
              }
              return acc
            },
            []
          );
      }
  Polymer({

    is: 'geo-visualizer',

    properties: {
      baseLat: {
        type: Number,
        notify: true,
        reflectToAttribute: true,
        value: 19.4333
      },
      baseLng: {
        type: Number,
        notify: true,
        reflectToAttribute: true,
        value: -99.1333
      }, 
      baseZoom: {
        type: Number,
        notify: true,
        reflectToAttribute: true,
        value: 5
      },
      mapReady: {
        type: Boolean,
        notify: true,
        value: false
      },
      gmap: {
        type: Object
      },
      views: {
        type: Object,
        value: function() { return {} } ,
        notify: true
      },
      services: {
        type: Object,
        notify: true,
        value: function(){
          return { 
            directions: null,
            places: null
          }
        }

      }
    },
    attached: function(){
      var self, map, gmap, dbView;
      self = this;    
      map = self.$$('google-map');
      map.latitude = self.baseLat;
      map.longitude = self.baseLng;
      map.zoom = self.baseZoom;
      map.addEventListener('google-map-ready', function () {
        console.log('Map initialized...');
        var gmap, dbView, viewMarkerImage, viewName;
        self.gmap = gmap = map.map;
        self.mapReady = true;
        self.services.directions = {};
        self.services.directions.request = new google.maps.DirectionsService();
        self.services.directions.render = new google.maps.DirectionsRenderer();
        self.services.directions.render.setMap(gmap);
        self.services.distance = new google.maps.DistanceMatrixService(); 

        gmap = map.map;
        dbView = self.querySelector('sql-view'); 
        viewName =  (dbView.getAttribute('name') || "view");
        viewMarkerImage = (dbView.getAttribute('data-markericon') || null);
        if (dbView.viewData){
          console.log("Received db data...");
          self.processViewData.call(
            self,
            viewName,
            dbView.viewData,
            (dbView.getAttribute('data-titlecol') || Object.keys(dbView.viewData[0])[0]),
            viewMarkerImage,
            self.renderViewMarkers.bind(self, viewName)
          );
        }else {
          dbView.addEventListener('db-data', 
            function(evnt){ 
              console.log("Received db data...");
              self.processViewData.call(
                self,
                viewName,                
                evnt.detail,
                (dbView.getAttribute('data-titlecol') || Object.keys(evnt.detail[0])[0]),
                viewMarkerImage,
                self.renderViewMarkers.bind(self, viewName)
              );
            }
          )
        }
      });
    },


    processViewData: function(name, data, titleCol, viewImage, callback){
      console.log("Processing "+name+" data...");
      var self, geokeys, processed;
      self = this; 
      geokeys = self.geoKeys(Object.keys(utils.car(data)));
      data = data.filter(
        function(row){
          return row[geokeys[0]] && row[geokeys[1]]
        }
      );
      processed = {
        data: data,
        geocode: self.viewGeocoding(data),
        title: titleCol,
        icon: viewImage
      };
      self.views[name] = processed;
      if (callback){
        callback(processed);
      }
      self.fire('data-acquired', name)
    },
    geoKeys: function(dims){
      return [
      dims.filter(
      function(k){ 
          return /lat/gi.test(k)
        }
      )[0],
      dims.filter(
        function(k){ 
          return /lng|longitud/gi.test(k)
        }
      )[0] 
      ]
    },
    viewGeocoding: function(viewData){ 
      console.log("Generating geocoding...");
      console.log(viewData);
      var self, dims, geokeys, latKey, lngKey;
      self = this;
      geokeys = self.geoKeys(Object.keys(utils.car(viewData))); 
      latKey = geokeys[0]; 
      lngKey = geokeys[1]; 
      return viewData.map(
        function (row, i){
          var rlat, rlng;
          rlat = row[latKey];
          rlng = row[lngKey];
          if (rlat && rlng){
           // return new google.maps.LatLng(rlat, rlng);
            return new google.maps.LatLng(Number(rlat), Number(rlng))
          }
          return null
        }
      )
    },

    infoWindowHTML: function(row, titleCol){ 
      var dataItems;
      var INCOME_COL = 'VTA_RL_PRM';


      return '<table>\n' +
              '<tr>\n'+
              '<th>VENDEDOR</th>\n'+
              '<td>'+row.POS_ID_AGENTE+'</td>\n'+
              '</tr>\n'+
               '<tr>\n'+
              '<th>NOMBRE</th>\n'+
              '<td>'+row.NOMBRE+'</td>\n'+
              '</tr>\n'+
              '<tr>\n'+
              '<th>CLASE</th>\n'+
              '<td>'+row.CLASE_CLIENTE+'</td>\n'+
              '</tr>\n'+
              '<tr>\n'+
              '<th>Vantas Promedio</th>\n'+
              '<td>'+row.VTA_RL_PRM+'</td>\n'+
              '</tr>\n' + 
              '</table>\n'
    },

    renderViewMarkers: function(viewName){ 
      console.log('Rendering '+viewName+' markers...');
      var self, gmap, mapDom, view, data, icon, geocoding;
      self = this;
      gmap = self.gmap;
      view = self.views[viewName]; 
      data = view.data;
      icon = view.icon;
      geocoding = view.geocode; 
      titles = view.data.map(utils.getKeyFrom(view.title)); 
      function addMarker(marker){ 
        Polymer.dom(self.querySelector('google-map')).appendChild(marker)
      }
      geocoding.forEach(
        function(gc, i){ 
          if (gc){
            var marker, markerSpecs, inforW;
            markerSpecs = {
              position: gc,
              title: titles[i],
              map: gmap,
              lable: titles[i]
            };
            if (view.icon){ 
              markerSpecs.icon = view.icon;
            }
            marker = new google.maps.Marker(markerSpecs);
            
            google.maps.event.addListener(marker, 'click', 

              function() {
                var infoW = new google.maps.InfoWindow({ 
                    content: self.infoWindowHTML(data[i], view.title) 
                });
                infoW.open(gmap, marker);
                console.log(JSON.stringify(data[i]));
              }
            );
            //infoW.open(gmap, marker);
          }
        },
        []
      );
    },

    viewMarkers: function(viewData){
      var self, dims, latKey, lngKey;
      console.log("Generating markers...");
      self = this;
      dims = Object.keys(utils.car(viewData)); 
      latKey = dims.filter(
        function(k){ 
          return /lat/gi.test(k)
        }
      )[0]; 
      lngKey = dims.filter(
        function(k){ 
          return /lng|longitud/gi.test(k)
        }
      )[0]; 
      return viewData.reduce( 
        function (markers, row, i){ 
          var rlat, rlng, pos, rmarker;
          rlat = row[latKey];
          rlng = row[lngKey];

          if (rlat && rlng){
            pos = new google.maps.LatLng(rlat, rlng);
            rmarker = new google.maps.Marker({
              position: pos, 
              title: String(i),
              animation: google.maps.Animation.DROP,
            });
            rmarker.latitude = parseInt(rlat, 10);
            rmarker.longitude = parseInt(rlng, 10); 
            markers = markers.concat(rmarker);
          }
          return markers
        }, 
        []
      ); 
    },

    viewDistances: function(viewName, start, callback){
      var self, viewKey, dist, view, getDist;
      self = this; 
      viewKey = viewDistanceKey(viewName, start);
      dist = window.localStorage.getItem(viewKey);
      getDist = self.services.distance.getDistanceMatrix;
      console.log(dist);
      if (dist){
        var view, ss, gc, gcr, dm;
        view = self.views[viewName]; 
        gc = view.geocode;
        gc.unshift(start);
        gcr = utils.range(gc.length);
        ss = combinations(arraySubsets(gcr, 10), 2); 
        dm = gcr.map(function(){ return gcr });
        console.log(ss);
        console.log(dm);
        async.reduce(
          ss,
          dm,
          function getBatch(acc, s, cb){
            var tm, dt; 
            dt = new Date();
            tm = dt.getTime();
            console.log(acc);
            getDist({
                origins: ssgc(s[0]),
                destinations: ssgc(s[1]),
                travelMode: google.maps.TravelMode.DRIVING
              },
              function(res, status){
                if (status === "OK"){
                  s[0].forEach(
                    function(v0, i0){
                      s[1].forEach(
                        function(v1, i1){
                          acc[v0][v1] = acc[v1][v0] = res.rows[i0].elements[i1];
                        }
                      )
                    }
                  );
                  console.log(acc);
                  ctm = 10000 - (dt.getTime() - tm); 
                  console.log(ctm);
                  if (ctm > 0){
                    setTimeout(function(){cb(null, acc)}, ctm);
                    return
                  }
                  cb(null, acc);
                  return
                }
                cb(status);
                return 
              }
            );
          },
          function (err, res){
            if (err){
              console.log(err);
              callback(err);
              return
            }
            console.log("DISTANCES");

            console.log(res);
            window.localStorage.setItem(viewKey, res);
            callback(null, res); 
          }
        );
      } else {
        console.log(dist);
        callback(null, dist);
      }

      function ssgc(ix){
        return ix.map(function(v){ return gc[v] })
      }
      function viewDistanceKey(viewName, start){
        return viewName + '_' +String(start.G)+','+String(start.K)+'_DISTANCES'
      }
      function arraySubsets(arr, slen){
        var nsubs, subs, ln;
        ln = arr.length;
        nsubs = Math.floor(ln/slen);
        console.log(ln);
        console.log(nsubs);
        subs = range(nsubs).map(function(sn){ 
          console.log(sn); 
          console.log(sn*slen);
          return arr.slice(sn*slen, (sn+1)*slen) }); 
        if (nsubs*slen < ln){
          subs = subs.concat([arr.slice(nsubs*slen, ln)]);
        }
        return subs
      }
    },
    calculateViewRoute: function(viewName, startLoc){ 
      var self, view, gc;
      self = this; 
      start =  startLoc.split(',').map(Number);
      start = new google.maps.LatLng(start[0], start[1]);
      view = self.views[viewName]; 
      gc = view.geocode;
      gc.unshift(start); 
      self.viewDistances(viewName, start, 
        function(err, res){
          if (err){ console.log(err); return }
          var possibleRoutes;
          possibleRoutes = possibleRoutes(view.geocode.length);
          console.log(possibleRoutes);
          console.log(res);
        }
      );
      function distanceOptimization(distArr){
          console.log("CALCULATING DISTANCE OPTIMIZATION")
          var candidates, distances;
          candidates = possibleRoutes(view.geocode.length); 
          console.log(candidates);
          distances = candidates.map(routeDistance(distArr)); 
          console.log(distances);
          return candidates[distances.indexOf(Math.min.apply(null, distances))].map(
          function(v){
            return gc[v]
          }
        )
      }
      
      function possibleRoutes(nstops){
        console.log("CALCULATING POSSIBLE ROUTES");
        console.log(nstops);
        return combinations(utils.range(nstops), 7).map(
          function (route){
            console.log(route);
            return [0].concat(route.map(function(v){ return v+1}))
          }
        ); 
      }
      function routeDistance(distArr){
        return function (route){
          return route.slice(1).reduce(
            function(d, v, i, arr){
              console.log(d);
              return d + distArr[v][route[i-1]].distance.value
            },
            0
          )
        }
      }
      function directionsRequest(route){
        var rl;
        rl = route.length;
        return {
          origin: route[0],
          destination: route[rl-1],
          waypoints: route.slice(1, rl-2),
          optimizeWaypoints: true, 
          travelMode: "DRIVING"
        }
      }

      // wypnts = stopGeocodes.slice(1, lstStop).map( 
      //   function (w){ 
      //     return { 
      //       location : w,
      //       stopover: true
      //     }
      //   }
      // );
      // request = { 
      //   origin: start,
      //   destination: stopGeocodes[lstStop],
      //   waypoints: wypnts,
      //   optimizeWaypoints: true, 
      //   travelMode: "DRIVING"
      // }
      // console.log("Requesting route: "); 
      // console.log(request);
      // self.services.directions.request.route(request, 
      //   function (res, status){ 
      //     console.log("Route request fulfilled with status: "+status);
      //     if (status == google.maps.DirectionsStatus.OK) {
      //       self.services.directions.render.setDirections(res);
      //     }
      //   }
      // );
     function valueFilter(d, k, vs){
        var ixs, retFn;
        ixs = d.reduce(
          function (a, v, i){ 
            if (vs.indexOf(v[k]) !== -1){
              a = a.concat(i); 
            }
            return a
          },
          []
        ); 
        retFn = function (v, i){
          return ixs.indexOf(i) !== -1
        }
        retFn.filtered = ixs.map(function(v){ return d[v] });
        return retFn
      }
    }
  });

</script>
