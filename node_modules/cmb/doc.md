#Index

**Classes**

* [class: Comb](#Comb)
  * [new Comb(set, k, cb)](#new_Comb)
  * [Comb~each(cb)](#Comb..each)
  * [Comb~next()](#Comb..next)

**Functions**

* [Stream(set, k)](#Stream)
 
<a name="Comb"></a>
#class: Comb
**Members**

* [class: Comb](#Comb)
  * [new Comb(set, k, cb)](#new_Comb)
  * [Comb~each(cb)](#Comb..each)
  * [Comb~next()](#Comb..next)

<a name="new_Comb"></a>
##new Comb(set, k, cb)
Given a set and the number of elements you want to have in a
combination, comb returns an iterator object, with the methods
`next` and `rewind`. If a callback function is given, it is
executed for each element right away.

**Params**

- set `Array`  
- k `number`  
- cb `function`  

**Returns**: `Object`  
**Example**  
var c = new Comb([1,2,3], 2);
c.next() // {done: false, value: [1,2]}
c.next() // {done: false, value: [1,3]}
c.next() // {done: false, value: [2,3]}
c.next() // {done: true}
c.rewind() // true
c.next() // {done: false, value: [1,2]}

<a name="Comb..each"></a>
##Comb~each(cb)
Execute function for each element until there are no more
elements or the combination.BREAK object is returned from the
callback. This method does NOT rewind beforehand, you have to
do that yourself.

**Params**

- cb `function`  

**Scope**: inner function of [Comb](#Comb)  
**Returns**:  - void  
<a name="Comb..next"></a>
##Comb~next()
return the next element

**Scope**: inner function of [Comb](#Comb)  
**Returns**: `Object`  
<a name="Stream"></a>
#Stream(set, k)
Creates a readable stream of combinations

**Params**

- set `array`  
- k `number`  

**Returns**:  - stream.Readable  
**Example**  
var cstr = new Comb.Stream([1,2,3,4,5], 2);
cstr.read() // [ 1, 2 ]
cstr.read() // [ 1, 3 ]
cstr.on('data', console.log.bind(console));
[ 1, 4 ]
[ 1, 5 ]
[ 2, 3 ]
[ 2, 4 ]
[ 2, 5 ]
[ 3, 4 ]
[ 3, 5 ]
[ 4, 5 ]
null

